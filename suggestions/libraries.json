{
  "basic": [
    {
      "text": "_VERSION",
      "type": "variable",
      "rightLabelHTMLHTML": "<b>_VERSION</b>",
      "description": "Returns the lua api version being used (e.i., 'Lua 5.3').",
      "descriptionMoreURL": "#pdf-_VERSION",
      "replacementPrefix": "ver"
    },
    {
      "snippet": "print '${1:Hello world!}'$0",
      "type": "function",
      "rightLabelHTMLHTML": "<b>print</b> 'message'",
      "description": "Prints the given string.",
      "descriptionMoreURL": "#pdf-print",
      "replacementPrefix": "prin"
    },
    {
      "snippet": "print(${1:message})$0",
      "type": "function",
      "rightLabelHTMLHTML": "<b>print</b>(message)",
      "description": "Prints the given value, converting the given value to a string.",
      "descriptionMoreURL": "#pdf-print",
      "replacementPrefix": "print"
    },
    {
      "snippet": "tonumber(${1:value}, ${2:base})$0",
      "type": "function",
      "rightLabelHTMLHTML": "<b>tonumber</b>(value [, base])",
      "description": "Returns the given argument as a number.",
      "descriptionMoreURL": "#pdf-tonumber",
      "replacementPrefix": "tonumber"
    },
    {
      "snippet": "tostring(${1:value})$0",
      "type": "function",
      "rightLabelHTMLHTML": "<b>tostring</b>(value)",
      "description": "Returns the given argument as a string in a human-readable format.",
      "descriptionMoreURL": "#pdf-tostring",
      "replacementPrefix": "tostring"
    },
    {
      "snippet": "type(${1:any})$0",
      "type": "function",
      "rightLabelHTMLHTML": "<b>type</b>(any)",
      "description": "Returns the type of its only argument, coded as a string.",
      "descriptionMoreURL": "#pdf-type",
      "replacementPrefix": "type"
    },
    {
      "snippet": "assert(${1:value}, ${2:message})$0",
      "type": "function",
      "rightLabelHTMLHTML": "<b>assert</b>(value [, message])",
      "description": "Calls 'error' function if the 'value' is false (i.e., nil or false); otherwise, returns all its arguments.",
      "descriptionMoreURL": "#pdf-assert",
      "replacementPrefix": "assert"
    },
    {
      "snippet": "collectgarbage(${1:option}, ${2:argument})$0",
      "type": "function",
      "rightLabelHTMLHTML": "<b>collectgarbage</b>([option [, argument]])",
      "description": "This function is a generic interface to the garbage collector.",
      "descriptionMoreURL": "#pdf-collectgarbage",
      "replacementPrefix": "garbage"
    },
    {
      "snippet": "error(${1:message}, ${2:level})$0",
      "type": "function",
      "rightLabelHTMLHTML": "<b>error</b>(message [, level])",
      "description": "Terminates the last protected function called and returns 'message' as the error object.",
      "descriptionMoreURL": "#pdf-error",
      "replacementPrefix": "error"
    },
    {
      "snippet": "select(${1:index})$0",
      "type": "function",
      "rightLabelHTMLHTML": "<b>select</b>(index, ···)",
      "description": "Returns all arguments after argument number 'index'.",
      "descriptionMoreURL": "#pdf-select",
      "replacementPrefix": "select"
    },
    {
      "snippet": "next(${1:table}, ${2:index})$0",
      "type": "function",
      "rightLabelHTMLHTML": "<b>next</b>(table [, index])",
      "description": "Allows a program to traverse all fields of a table.",
      "descriptionMoreURL": "#pdf-next",
      "replacementPrefix": "next"
    },
    {
      "snippet": "getmetatable(${1:object})$0",
      "type": "function",
      "rightLabelHTMLHTML": "<b>getmetatable</b>(object)",
      "description": "Returns the 'table' metamethod field '__metatable' associated value, if the field doens't exist returns nil.",
      "descriptionMoreURL": "#pdf-getmetatable",
      "replacementPrefix": "getmetatable"
    },
    {
      "snippet": "setmetatable(${1:table}, ${2:metatable})$0",
      "type": "function",
      "rightLabelHTMLHTML": "<b>setmetatable</b>(table, metatable)",
      "description": "Sets the metatable for the given table.",
      "descriptionMoreURL": "#pdf-setmetatable",
      "replacementPrefix": "setmetatable"
    },
    {
      "snippet": "pairs(${1:table})$0",
      "type": "function",
      "rightLabelHTMLHTML": "<b>pairs</b>(table)",
      "description": "Calls the 'table' metamethod field '__pairs' with 'table' as argument, alongside with the first three results from the call.",
      "descriptionMoreURL": "#pdf-pairs",
      "replacementPrefix": "pairs"
    },
    {
      "snippet": "ipairs(${1:table})$0",
      "type": "function",
      "rightLabelHTMLHTML": "<b>ipairs</b>(table)",
      "description": "Returns three values (an iterator function, the 'table', and 0).",
      "descriptionMoreURL": "#pdf-ipairs",
      "replacementPrefix": "ipairs"
    },
    {
      "snippet": "dofile(${1:fileName})$0",
      "type": "function",
      "rightLabelHTMLHTML": "<b>dofile</b>([fileName])",
      "description": "Opens the named file and executes its contents as a Lua chunk.",
      "descriptionMoreURL": "#pdf-dofile",
      "replacementPrefix": "dofile"
    },
    {
      "snippet": "load(${1:chunk}, ${2:chunkName}, ${3:mode}, ${4:env})$0",
      "type": "function",
      "rightLabelHTMLHTML": "<b>load</b>(chunk [, chunkName [, mode [, env]]])",
      "description": "Loads a chunk.",
      "descriptionMoreURL": "#pdf-load",
      "replacementPrefix": "load"
    },
    {
      "snippet": "loadfile(${1:fileName}, ${2:mode}, ${3:env})$0",
      "type": "function",
      "rightLabelHTMLHTML": "<b>loadfile</b>([fileName [, mode [, env]]])",
      "description": "Similar to 'load', but gets the chunk from 'fileName' or from the standard input, if no file name is given.",
      "descriptionMoreURL": "#pdf-loadfile",
      "replacementPrefix": "loadfile"
    },
    {
      "snippet": "pcall(${1:func}, ${2:argument})$0",
      "type": "function",
      "rightLabelHTMLHTML": "<b>pcall</b>(func [, argument, ···])",
      "description": "Calls 'function' with the given arguments in protected mode.",
      "descriptionMoreURL": "#pdf-pcall",
      "replacementPrefix": "callp"
    },
    {
      "snippet": "xpcall(${1:func}, ${2:msgh}, ${3:argument})$0",
      "type": "function",
      "rightLabelHTMLHTML": "<b>xpcall</b>(func, msgh [, argument, ···])",
      "description": "This 'function' is similar to pcall, except that it sets a new message handler.",
      "descriptionMoreURL": "#pdf-xpcall",
      "replacementPrefix": "callxp"
    },
    {
      "snippet": "rawget(${1:table}, ${2:index})$0",
      "type": "function",
      "rightLabelHTMLHTML": "<b>rawget</b>(table, index)",
      "description": "Gets the real value of 'table[index]', without invoking the '__index' metamethod.",
      "descriptionMoreURL": "#pdf-rawget",
      "replacementPrefix": "rawget"
    },
    {
      "snippet": "rawset(${1:table}, ${2:index}, ${3:value})$0",
      "type": "function",
      "rightLabelHTMLHTML": "<b>rawset</b>(table, index, value)",
      "description": "Sets the real value of 'table[index]' to value, without invoking the '__newindex' metamethod.",
      "descriptionMoreURL": "#pdf-rawset",
      "replacementPrefix": "rawset"
    },
    {
      "snippet": "rawequal(${1:value1}, ${2:value2})$0",
      "type": "function",
      "rightLabelHTMLHTML": "<b>rawequal</b>(value1, value2)",
      "description": "Checks whether 'value1' is equal to 'value2', without invoking the '__eq' metamethod. Returns a boolean. ",
      "descriptionMoreURL": "#pdf-rawequal",
      "replacementPrefix": "rawequal"
    },
    {
      "snippet": "rawlen(${1:object})$0",
      "type": "function",
      "rightLabelHTMLHTML": "<b>rawlen</b>(object)",
      "description": "Returns the length of the 'object', which must be a table or a string, without invoking the '__len' metamethod. Returns an integer.",
      "descriptionMoreURL": "#pdf-rawlen",
      "replacementPrefix": "rawlen"
    }
  ],
  "coroutine": [
    {
      "snippet": "coroutine.create(${1:func})$0",
      "type": "function",
      "rightLabelHTML": "<b>coroutine</b>.<b>create</b>(func)",
      "description": "Creates a new coroutine, with body 'func'.",
      "descriptionMoreURL": "#pdf-coroutine.create",
      "replacementPrefix": "corocreate"
    },
    {
      "snippet": "coroutine.wrap(${1:func})$0",
      "type": "function",
      "rightLabelHTML": "<b>coroutine</b>.<b>wrap</b>(func)",
      "description": "Creates a new coroutine, with body 'func'.",
      "descriptionMoreURL": "#pdf-coroutine.wrap",
      "replacementPrefix": "corowrap"
    },
    {
      "snippet": "coroutine.status(${1:coro})$0",
      "type": "function",
      "rightLabelHTML": "<b>coroutine</b>.<b>status</b>(coro)",
      "description": "Returns the status of the given coroutine, as a string.",
      "descriptionMoreURL": "#pdf-coroutine.status",
      "replacementPrefix": "corostatus"
    },
    {
      "snippet": "coroutine.running()$0",
      "type": "function",
      "rightLabelHTML": "<b>coroutine</b>.<b>running</b>()",
      "description": "Returns the running coroutine and a boolean.",
      "descriptionMoreURL": "#pdf-coroutine.running",
      "replacementPrefix": "cororunning"
    },
    {
      "snippet": "coroutine.resume(${1:coro}, ${2:value})$0",
      "type": "function",
      "rightLabelHTML": "<b>coroutine</b>.<b>resume</b>(coro [, value, ···])",
      "description": "Starts or continues the execution of a given coroutine.",
      "descriptionMoreURL": "#pdf-coroutine.resume",
      "replacementPrefix": "cororesume"
    },
    {
      "snippet": "coroutine.isyieldable()$0",
      "type": "function",
      "rightLabelHTML": "<b>coroutine</b>.<b>isyieldable</b>()",
      "description": "Returns true when the running coroutine can yield.",
      "descriptionMoreURL": "#pdf-coroutine.isyieldable",
      "replacementPrefix": "coroisyieldable"
    },
    {
      "snippet": "coroutine.yield($1)$0",
      "type": "function",
      "rightLabelHTML": "<b>coroutine</b>.<b>yield</b>([···])",
      "description": "Suspends the execution of the calling coroutine.",
      "descriptionMoreURL": "#pdf-coroutine.yield",
      "replacementPrefix": "coroyield"
    }
  ],
  "package": [
    {
      "snippet": "require '${1:modName}'$0",
      "type": "function",
      "rightLabelHTML": "<b>require</b> 'modName'",
      "description": "Loads the given module.",
      "descriptionMoreURL": "#pdf-require",
      "replacementPrefix": "req"
    },
    {
      "snippet": "require(${1:modName})$0",
      "type": "function",
      "rightLabelHTML": "<b>require</b>(modName)",
      "description": "Loads the given module.",
      "descriptionMoreURL": "#pdf-require",
      "replacementPrefix": "req1"
    },
    {
      "snippet": "package.path '${1:path}'$0",
      "type": "function",
      "rightLabelHTML": "<b>package</b>.<b>path</b> 'path'",
      "description": "The path used by require to search for a Lua loader.",
      "descriptionMoreURL": "#pdf-package.path",
      "replacementPrefix": "packpath"
    },
    {
      "snippet": "package.cpath '${1:path}'$0",
      "type": "function",
      "rightLabelHTML": "<b>package</b>.<b>cpath</b> 'path'",
      "description": "The path used by 'require' to search for a C loader.",
      "descriptionMoreURL": "#pdf-package.cpath",
      "replacementPrefix": "packcpath"
    },
    {
      "snippet": "package.preload '${1:modName}'$0",
      "type": "function",
      "rightLabelHTML": "<b>package</b>.<b>preload</b> 'modName'",
      "description": "A table to store loaders for specific modules.",
      "descriptionMoreURL": "#pdf-package.preload",
      "replacementPrefix": "packpreload"
    },
    {
      "snippet": "package.loaded '${1:modName}'$0",
      "type": "function",
      "rightLabelHTML": "<b>package</b>.<b>loaded</b> 'modName'",
      "description": "A table used by 'require' to control which modules are already loaded.",
      "descriptionMoreURL": "#pdf-package.loaded",
      "replacementPrefix": "packloaded"
    },
    {
      "snippet": "package.loadlib(${1:libname}, ${2:func})$0",
      "type": "function",
      "rightLabelHTML": "<b>package</b>.<b>loadlib</b>(libName, func)",
      "description": "Dynamically links the host program with the C library 'libName'.",
      "descriptionMoreURL": "#pdf-package.loadlib",
      "replacementPrefix": "packloadlib"
    },
    {
      "snippet": "package.searchers '${1:path}'$0",
      "type": "function",
      "rightLabelHTML": "<b>package</b>.<b>searchers</b> 'path'",
      "description": "A table used by 'require' to control how to load modules. ",
      "descriptionMoreURL": "#pdf-package.searchers",
      "replacementPrefix": "packsearchers"
    },
    {
      "snippet": "package.searchpath(${1:name}, ${2:path}, ${3:sep}, ${4:rep})$0",
      "type": "function",
      "rightLabelHTML": "<b>package</b>.<b>searchpath</b>(name, path [, sep [, rep]])",
      "description": "Searches for the given name in the given 'path'.",
      "descriptionMoreURL": "#pdf-package.searchpath",
      "replacementPrefix": "packsearchpath"
    },
    {
      "snippet": "package.config '${1:config}'$0",
      "type": "function",
      "rightLabelHTML": "<b>package</b>.<b>config</b> 'config'",
      "description": "A string describing some compile-time configurations for packages.",
      "descriptionMoreURL": "#pdf-package.config",
      "replacementPrefix": "packconfig"
    }
  ],
  "string": [
    {
      "snippet": "string.byte(${1:s}, ${2:i}, ${3:j})$0",
      "type": "function",
      "rightLabelHTML": "<b>string</b>.<b>byte</b>(s [, i [, j]])",
      "description": "Returns the internal numeric codes of the characters 's[i]', 's[i+1]', ..., 's[j]'.",
      "descriptionMoreURL": "#pdf-string.byte",
      "replacementPrefix": "strbyte"
    },
    {
      "snippet": "string.char(${1:number})$0",
      "type": "function",
      "rightLabelHTML": "<b>string</b>.<b>char</b>([number , ···])",
      "description": "Returns a string with length equal to the number of arguments, in which each character has the internal numeric code equal to its corresponding argument.",
      "descriptionMoreURL": "#pdf-string.char",
      "replacementPrefix": "strchar"
    },
    {
      "snippet": "string.dump(${1:func}, ${2:strip})$0",
      "type": "function",
      "rightLabelHTML": "<b>string</b>.<b>dump</b>(func, strip)",
      "description": "Returns a string containing a binary representation (a binary chunk) of the given function.",
      "descriptionMoreURL": "#pdf-string.dump",
      "replacementPrefix": "strdump"
    },
    {
      "snippet": "string.find(${1:s}, ${2:pattern}, ${3:init}, ${4:plain})$0",
      "type": "function",
      "rightLabelHTML": "<b>string</b>.<b>find</b>(s, pattern [, init [, plain]])",
      "description": "Looks for the first match of pattern in the string 's'.",
      "descriptionMoreURL": "#pdf-string.find",
      "replacementPrefix": "strfind"
    },
    {
      "snippet": "string.format(${1:formatString}, ${2:s})$0",
      "type": "function",
      "rightLabelHTML": "<b>string</b>.<b>format</b>(formatString [, s])",
      "description": "Returns a formatted version of its variable number of arguments following the description given in its first argument (which must be a string).",
      "descriptionMoreURL": "#pdf-string.format",
      "replacementPrefix": "strformat"
    },
    {
      "snippet": "string.len(${1:s})$0",
      "type": "function",
      "rightLabelHTML": "<b>string</b>.<b>len</b>(s)",
      "description": "Receives a string 's' and returns its length.",
      "descriptionMoreURL": "#pdf-string.len",
      "replacementPrefix": "strlen"
    },
    {
      "snippet": "string.rep(${1:s}, ${2:n}, ${3:sep})$0",
      "type": "function",
      "rightLabelHTML": "<b>string</b>.<b>rep</b>(s, n [, sep])",
      "description": "Returns a string that is the concatenation of 'n' copies of the string 's' separated by the string 'sep'.",
      "descriptionMoreURL": "#pdf-string.rep",
      "replacementPrefix": "strrep"
    },
    {
      "snippet": "string.reverse(${1:s})$0",
      "type": "function",
      "rightLabelHTML": "<b>string</b>.<b>reverse</b>(s)",
      "description": "Returns a string that is the string 's' reversed.",
      "descriptionMoreURL": "#pdf-string.reverse",
      "replacementPrefix": "strreverse"
    },
    {
      "snippet": "string.upper(${1:s})$0",
      "type": "function",
      "rightLabelHTML": "<b>string</b>.<b>upper</b>(s)",
      "description": "Receives a string and returns a copy of this string 's' with all characters to uppercase.",
      "descriptionMoreURL": "#pdf-string.upper",
      "replacementPrefix": "strupper"
    },
    {
      "snippet": "string.lower(${1:s})$0",
      "type": "function",
      "rightLabelHTML": "<b>string</b>.<b>lower</b>(s)",
      "description": "Receives a string and returns a copy of this string 's' with all characters to lowercase.",
      "descriptionMoreURL": "#pdf-string.lower",
      "replacementPrefix": "strlower"
    },
    {
      "snippet": "string.gmatch(${1:s}, ${2:pattern})$0",
      "type": "function",
      "rightLabelHTML": "<b>string</b>.<b>gmatch</b>(s, pattern)",
      "description": "Returns an iterator function that, each time it is called, returns the next captures from 'pattern' over the string 's'.",
      "descriptionMoreURL": "#pdf-string.gmatch",
      "replacementPrefix": "strgmatch"
    },
    {
      "snippet": "string.gsub(${1:s}, ${2:pattern}, ${3:repl}, ${4:n})$0",
      "type": "function",
      "rightLabelHTML": "<b>string</b>.<b>gsub</b>(s, pattern, repl [, n])",
      "description": "Replaces the part string 's' that matches 'pattern' with 'repl'.",
      "descriptionMoreURL": "#pdf-string.gsub",
      "replacementPrefix": "strgsub"
    },
    {
      "snippet": "string.match(${1:s}, ${2:pattern}, ${3:init})$0",
      "type": "function",
      "rightLabelHTML": "<b>string</b>.<b>match</b>(s, pattern [, init])",
      "description": "Looks for the first match of 'pattern' in the string 's'.",
      "descriptionMoreURL": "#pdf-string.match",
      "replacementPrefix": "strmatch"
    },
    {
      "snippet": "string.sub(${1:s}, ${2:i}, ${3:j})$0",
      "type": "function",
      "rightLabelHTML": "<b>string</b>.<b>sub</b>(s, i [, j])",
      "description": "Returns the substring of string 's' that starts at 'i' and continues until 'j'; 'i' and 'j' can be negative.",
      "descriptionMoreURL": "#pdf-string.sub",
      "replacementPrefix": "strsub"
    },
    {
      "snippet": "string.unpack(${1:fmt}, ${2:s}, ${3:pos})$0",
      "type": "function",
      "rightLabelHTML": "<b>string</b>.<b>unpack</b>(fmt, s [, pos])",
      "description": "Returns the values packed in string 's' according to the format string 'fmt'.",
      "descriptionMoreURL": "#pdf-string.unpack",
      "replacementPrefix": "strunpack"
    },
    {
      "snippet": "string.pack(${1:fmt}, ${2:argument})$0",
      "type": "function",
      "rightLabelHTML": "<b>string</b>.<b>pack</b>(fmt, argument, ···)",
      "description": "Returns a binary string containing arguments packed according to the format string 'fmt'.",
      "descriptionMoreURL": "#pdf-string.pack",
      "replacementPrefix": "strpack"
    },
    {
      "snippet": "string.packsize(${1:fmt})$0",
      "type": "function",
      "rightLabelHTML": "<b>string</b>.<b>packsize</b>(fmt)",
      "description": "Returns the size of a string resulting from 'string.pack' with the given format.",
      "descriptionMoreURL": "#pdf-string.packsize",
      "replacementPrefix": "strpacksize"
    }
  ],
  "utf8": [
    {
      "snippet": "utf8.char(${1:number})$0",
      "type": "function",
      "rightLabelHTML": "<b>utf8</b>.<b>char</b>([number, ···])",
      "description": "Converts each one to its corresponding UTF-8 byte sequence and returns a string with the concatenation of all these sequences.",
      "descriptionMoreURL": "#pdf-utf8.char",
      "replacementPrefix": "utfchar"
    },
    {
      "snippet": "utf8.charpattern '${1:pattern}'$0",
      "type": "function",
      "rightLabelHTML": "<b>utf8</b>.<b>charpattern</b> 'pattern'",
      "description": "The pattern (a string, not a function) '[\\0-\\x7F\\xC2-\\xF4][\\x80-\\xBF]*', which matches exactly one UTF-8 byte sequence, assuming that the subject is a valid UTF-8 string. ",
      "descriptionMoreURL": "#pdf-utf8.charpattern",
      "replacementPrefix": "utfcharpattern"
    },
    {
      "snippet": "utf8.codes(${1:s})$0",
      "type": "function",
      "rightLabelHTML": "<b>utf8</b>.<b>codes</b>(s)",
      "description": "Returns values for a iterator function (for in).",
      "descriptionMoreURL": "#pdf-utf8.codes",
      "replacementPrefix": "utfcodes"
    },
    {
      "snippet": "utf8.codepoint(${1:s}, ${2:i}, ${3:j})$0",
      "type": "function",
      "rightLabelHTML": "<b>utf8</b>.<b>codepoint</b>(s [, i [, j]])",
      "description": "Returns the codepoints (as integers) from all characters in 's' that start between byte position 'i' and 'j' (both included).",
      "descriptionMoreURL": "#pdf-utf8.codepoint",
      "replacementPrefix": "utfcodepoint"
    },
    {
      "snippet": "utf8.len(${1:s}, ${2:i}, ${3:j})$0",
      "type": "function",
      "rightLabelHTML": "<b>utf8</b>.<b>len</b>(s [, i [, j]])",
      "description": "Returns the number of UTF-8 characters in string 's' that start between positions 'i' and 'j' (both inclusive).",
      "descriptionMoreURL": "#pdf-utf8.len",
      "replacementPrefix": "utflen"
    },
    {
      "snippet": "utf8.offset(${1:s}, ${2:n}, ${3:i})$0",
      "type": "function",
      "rightLabelHTML": "<b>utf8</b>.<b>offset</b>(s, n [, i])",
      "description": "Returns the position (in bytes) where the encoding of the 'n'-th character of 's' (counting from position 'i') starts.",
      "descriptionMoreURL": "#pdf-utf8.offset",
      "replacementPrefix": "utfoffset"
    }
  ],
  "table": [
    {
      "snippet": "table.concat(${1:list}, ${2:sep}, ${3:i}, ${4:j})$0",
      "type": "function",
      "rightLabelHTML": "<b>table</b>.<b>concat</b>(list [, sep [, i [, j]]])",
      "description": "Given a list where all elements are strings or numbers, returns the string 'list[i]'..'sep'..'list[i+1]' ··· 'sep..list[j]'.",
      "descriptionMoreURL": "#pdf-table.concat",
      "replacementPrefix": "tabconcat"
    },
    {
      "snippet": "table.insert(${1:list}, ${3:pos}, ${2:value})$0",
      "type": "function",
      "rightLabelHTML": "<b>table</b>.<b>insert</b>(list, [pos,] value)",
      "description": "Inserts element value at position 'pos' in 'list', shifting up the elements 'list[pos]', 'list[pos+1]', ···, 'list[#list]'.",
      "descriptionMoreURL": "#pdf-table.insert",
      "replacementPrefix": "tabinsert"
    },
    {
      "snippet": "table.remove(${1:list}, ${2:pos})$0",
      "type": "function",
      "rightLabelHTML": "<b>table</b>.<b>remove</b>(list [, pos])",
      "description": "Removes from 'list' the element at position 'pos', returning the value of the removed element.",
      "descriptionMoreURL": "#pdf-table.remove",
      "replacementPrefix": "tabremove"
    },
    {
      "snippet": "table.move(${1:a1}, ${2:f}, ${3:e}, ${4:t}, ${5:a2})$0",
      "type": "function",
      "rightLabelHTML": "<b>table</b>.<b>move</b>(a1, f, e, t [,a2])",
      "description": "Moves elements from table 'a1' to table 'a2'.",
      "descriptionMoreURL": "#pdf-table.move",
      "replacementPrefix": "tabmove"
    },
    {
      "snippet": "table.sort(${1:list}, ${2:comp})$0",
      "type": "function",
      "rightLabelHTML": "<b>table</b>.<b>sort</b>(list [, comp])",
      "description": "Sorts list elements in a given order, in-place, from 'list[1]' to 'list[#list]'.",
      "descriptionMoreURL": "#pdf-table.sort",
      "replacementPrefix": "tabsort"
    },
    {
      "snippet": "table.unpack(${1:list}, ${2:i}, ${3:j})$0",
      "type": "function",
      "rightLabelHTML": "<b>table</b>.<b>unpack</b>(list [, i [, j]])",
      "description": "Returns the elements from the given list.",
      "descriptionMoreURL": "#pdf-table.unpack",
      "replacementPrefix": "tabunpack"
    },
    {
      "snippet": "table.pack($1)$0",
      "type": "function",
      "rightLabelHTML": "<b>table</b>.<b>pack</b>(···)",
      "description": "Returns a new table with all parameters stored into keys 1, 2, etc. and with a field \"n\" with the total number of parameters.",
      "descriptionMoreURL": "#pdf-table.pack",
      "replacementPrefix": "tabpack"
    }
  ],
  "math": [
    {
      "text": "math.pi",
      "type": "variable",
      "rightLabelHTML": "<b>math</b>.<b>pi</b>",
      "description": "The value of π.",
      "descriptionMoreURL": "#pdf-math.pi",
      "replacementPrefix": "mathpi"
    },
    {
      "snippet": "math.abs(${1:x})$0",
      "type": "function",
      "rightLabelHTML": "<b>math</b>.<b>abs</b>(x)",
      "description": "Returns the absolute value of 'x' (integer/float).",
      "descriptionMoreURL": "#pdf-math.abs",
      "replacementPrefix": "mathabs"
    },
    {
      "snippet": "math.acos(${1:x})$0",
      "type": "function",
      "rightLabelHTML": "<b>math</b>.<b>acos</b>(x)",
      "description": "Returns the arc cosine of 'x' (in radians).",
      "descriptionMoreURL": "#pdf-math.acos",
      "replacementPrefix": "mathacos"
    },
    {
      "snippet": "math.asin(${1:x})$0",
      "type": "function",
      "rightLabelHTML": "<b>math</b>.<b>asin</b>(x)",
      "description": "Returns the arc sine of 'x' (in radians).",
      "descriptionMoreURL": "#pdf-math.asin",
      "replacementPrefix": "mathasin"
    },
    {
      "snippet": "math.atan(${1:y}, ${2:x})$0",
      "type": "function",
      "rightLabelHTML": "<b>math</b>.<b>atan</b>(y [, x])",
      "description": "Returns the arc tangent of 'y'/'x' (in radians), but uses the signs of both parameters to find the quadrant of the result.",
      "descriptionMoreURL": "#pdf-math.atan",
      "replacementPrefix": "mathatan"
    },
    {
      "snippet": "math.ceil(${1:x})$0",
      "type": "function",
      "rightLabelHTML": "<b>math</b>.<b>ceil</b>(x)",
      "description": "Returns the smallest integral value larger than or equal to 'x'.",
      "descriptionMoreURL": "#pdf-math.ceil",
      "replacementPrefix": "mathceil"
    },
    {
      "snippet": "math.cos(${1:x})$0",
      "type": "function",
      "rightLabelHTML": "<b>math</b>.<b>cos</b>(x)",
      "description": "Returns the cosine of 'x' (assumed to be in radians).",
      "descriptionMoreURL": "#pdf-math.cos",
      "replacementPrefix": "mathcos"
    },
    {
      "snippet": "math.deg(${1:x})$0",
      "type": "function",
      "rightLabelHTML": "<b>math</b>.<b>deg</b>(x)",
      "description": "Converts the angle 'x' from radians to degrees.",
      "descriptionMoreURL": "#pdf-math.deg",
      "replacementPrefix": "mathdeg"
    },
    {
      "snippet": "math.exp(${1:x})$0",
      "type": "function",
      "rightLabelHTML": "<b>math</b>.<b>exp</b>(x)",
      "description": "Returns the value 'e^x' (where e is the base of natural logarithms).",
      "descriptionMoreURL": "#pdf-math.exp",
      "replacementPrefix": "mathexp"
    },
    {
      "snippet": "math.floor(${1:x})$0",
      "type": "function",
      "rightLabelHTML": "<b>math</b>.<b>floor</b>(x)",
      "description": "Returns the largest integral value smaller than or equal to 'x'.",
      "descriptionMoreURL": "#pdf-math.floor",
      "replacementPrefix": "mathfloor"
    },
    {
      "snippet": "math.fmod(${1:x}, ${2:y})$0",
      "type": "function",
      "rightLabelHTML": "<b>math</b>.<b>fmod</b>(x, y)",
      "description": "Returns the remainder of the division of 'x' by 'y' that rounds the quotient towards zero (integer/float).",
      "descriptionMoreURL": "#pdf-math.fmod",
      "replacementPrefix": "mathfmod"
    },
    {
      "snippet": "math.log(${1:x}, ${2:base})$0",
      "type": "function",
      "rightLabelHTML": "<b>math</b>.<b>log</b>(x [, base])",
      "description": "Returns the logarithm of 'x' in the given base. The default for base is 'e' (so that the function returns the natural logarithm of 'x').",
      "descriptionMoreURL": "#pdf-math.log",
      "replacementPrefix": "mathlog"
    },
    {
      "text": "math.huge",
      "type": "variable",
      "rightLabelHTML": "<b>math</b>.<b>huge</b>",
      "description": "The float value 'HUGE_VAL', a value larger than any other numeric value.",
      "descriptionMoreURL": "#pdf-math.huge",
      "replacementPrefix": "mathhuge"
    },
    {
      "snippet": "math.max(${1:x})$0",
      "type": "function",
      "rightLabelHTML": "<b>math</b>.<b>max</b>(x, ···)",
      "description": "Returns the argument with the maximum value, according to the Lua operator < (integer/float).",
      "descriptionMoreURL": "#pdf-math.max",
      "replacementPrefix": "mathmax"
    },
    {
      "text": "math.maxinteger",
      "type": "variable",
      "rightLabelHTML": "<b>math</b>.<b>maxinteger</b>",
      "description": "An integer with the maximum value for an integer.",
      "descriptionMoreURL": "#pdf-math.maxinteger",
      "replacementPrefix": "mathmaxinteger"
    },
    {
      "snippet": "math.min(${1:x})$0",
      "type": "function",
      "rightLabelHTML": "<b>math</b>.<b>min</b>(x, ···)",
      "description": "Returns the argument with the minimum value, according to the Lua operator < (integer/float).",
      "descriptionMoreURL": "#pdf-math.min",
      "replacementPrefix": "mathmin"
    },
    {
      "text": "math.mininteger",
      "type": "variable",
      "rightLabelHTML": "<b>math</b>.<b>mininteger</b>",
      "description": "An integer with the minimum value for an integer.",
      "descriptionMoreURL": "#pdf-math.mininteger",
      "replacementPrefix": "mathmininteger"
    },
    {
      "snippet": "math.modf(${1:x})$0",
      "type": "function",
      "rightLabelHTML": "<b>math</b>.<b>modf</b>(x)",
      "description": "Returns the integral part of 'x' and the fractional part of 'x'. Its second result is always a float.",
      "descriptionMoreURL": "#pdf-math.modf",
      "replacementPrefix": "mathmodf"
    },
    {
      "snippet": "math.rad(${1:x})$0",
      "type": "function",
      "rightLabelHTML": "<b>math</b>.<b>rad</b>(x)",
      "description": "Converts the angle 'x' from degrees to radians.",
      "descriptionMoreURL": "#pdf-math.rad",
      "replacementPrefix": "mathrad"
    },
    {
      "snippet": "math.random(${1:m}, ${2:n})$0",
      "type": "function",
      "rightLabelHTML": "<b>math</b>.<b>random</b>([m [, n]])",
      "description": "When called without arguments, returns a pseudo-random float with uniform distribution in the range '[0,1)'.",
      "descriptionMoreURL": "#pdf-math.random",
      "replacementPrefix": "mathrandom"
    },
    {
      "snippet": "math.randomseed(${1:x})$0",
      "type": "function",
      "rightLabelHTML": "<b>math</b>.<b>randomseed</b>(x)",
      "description": "Sets 'x' as the \"seed\" for the pseudo-random generator: equal seeds produce equal sequences of numbers.",
      "descriptionMoreURL": "#pdf-math.randomseed",
      "replacementPrefix": "mathrandomseed"
    },
    {
      "snippet": "math.sin(${1:x})$0",
      "type": "function",
      "rightLabelHTML": "<b>math</b>.<b>sin</b>(x)",
      "description": "Returns the sine of 'x' (assumed to be in radians).",
      "descriptionMoreURL": "#pdf-math.sin",
      "replacementPrefix": "mathsin"
    },
    {
      "snippet": "math.sqrt(${1:x})$0",
      "type": "function",
      "rightLabelHTML": "<b>math</b>.<b>sqrt</b>(x)",
      "description": "Returns the square root of 'x' (You can also use the expression 'x^0.5' to compute this value.).",
      "descriptionMoreURL": "#pdf-math.sqrt",
      "replacementPrefix": "mathsqrt"
    },
    {
      "snippet": "math.tan(${1:x})$0",
      "type": "function",
      "rightLabelHTML": "<b>math</b>.<b>tan</b>(x)",
      "description": "Returns the tangent of 'x' (assumed to be in radians).",
      "descriptionMoreURL": "#pdf-math.tan",
      "replacementPrefix": "mathtan"
    },
    {
      "snippet": "math.tointeger(${1:x})$0",
      "type": "function",
      "rightLabelHTML": "<b>math</b>.<b>tointeger</b>(x)",
      "description": "If the value 'x' is convertible to an integer, returns that integer. Otherwise, returns nil.",
      "descriptionMoreURL": "#pdf-math.tointeger",
      "replacementPrefix": "mathtointeger"
    },
    {
      "snippet": "math.type(${1:x})$0",
      "type": "function",
      "rightLabelHTML": "<b>math</b>.<b>type</b>(x)",
      "description": "Returns \"integer\" if 'x' is an integer, \"float\" if it is a float, or nil if 'x' is not a number.",
      "descriptionMoreURL": "#pdf-math.type",
      "replacementPrefix": "mathtype"
    },
    {
      "snippet": "math.ult(${1:m}, ${2:n})$0",
      "type": "function",
      "rightLabelHTML": "<b>math</b>.<b>ult</b>(m, n)",
      "description": "Returns a boolean, true if and only if integer 'm' is below integer 'n' when they are compared as unsigned integers.",
      "descriptionMoreURL": "#pdf-math.ult",
      "replacementPrefix": "mathult"
    }
  ],
  "io": [
    {
      "snippet": "io.close(${1:file})$0",
      "type": "function",
      "rightLabelHTML": "<b>io</b>.<b>close</b>([file])",
      "description": "Equivalent to 'file:close()'. Without a file, closes the default output file.",
      "descriptionMoreURL": "#pdf-io.close",
      "replacementPrefix": "ioclose"
    },
    {
      "snippet": "io.flush()$0",
      "type": "function",
      "rightLabelHTML": "<b>io</b>.<b>flush</b>()",
      "description": "Equivalent to 'io.output():flush()'.",
      "descriptionMoreURL": "#pdf-io.flush",
      "replacementPrefix": "ioflush"
    },
    {
      "snippet": "io.input(${1:file})$0",
      "type": "function",
      "rightLabelHTML": "<b>io</b>.<b>input</b>([file])",
      "description": "When called with a file name, it opens the named file (in text mode), and sets its handle as the default input file. When called with a file handle, it simply sets this file handle as the default input file. When called without parameters, it returns the current default input file.",
      "descriptionMoreURL": "#pdf-io.input",
      "replacementPrefix": "ioinput"
    },
    {
      "snippet": "io.lines(${1:fileName})$0",
      "type": "function",
      "rightLabelHTML": "<b>io</b>.<b>lines</b>([fileName, ···])",
      "description": "Opens the given file name in read mode and returns an iterator function that works like 'file:lines(···)' over the opened file.",
      "descriptionMoreURL": "#pdf-io.lines",
      "replacementPrefix": "iolines"
    },
    {
      "snippet": "io.open(${1:fileName}, ${2:mode})$0",
      "type": "function",
      "rightLabelHTML": "<b>io</b>.<b>open</b>(fileName [, mode])",
      "description": "This function opens a file, in the mode specified in the string 'mode'. In case of success, it returns a new file handle.",
      "descriptionMoreURL": "#pdf-io.open",
      "replacementPrefix": "ioopen"
    },
    {
      "snippet": "io.output(${1:file})$0",
      "type": "function",
      "rightLabelHTML": "<b>io</b>.<b>output</b>([file])",
      "description": "Similar to 'io.input', but operates over the default output file. ",
      "descriptionMoreURL": "#pdf-io.output",
      "replacementPrefix": "iooutput"
    },
    {
      "snippet": "io.popen(${1:prog}, ${2:mode})$0",
      "type": "function",
      "rightLabelHTML": "<b>io</b>.<b>popen</b>(prog [, mode])",
      "description": "This function is system dependent and is not available on all platforms.",
      "descriptionMoreURL": "#pdf-io.popen",
      "replacementPrefix": "iopopen"
    },
    {
      "snippet": "io.read($1)$0",
      "type": "function",
      "rightLabelHTML": "<b>io</b>.<b>read</b>(···)",
      "description": "Equivalent to 'io.input():read(···)'.",
      "descriptionMoreURL": "#pdf-io.read",
      "replacementPrefix": "ioread"
    },
    {
      "snippet": "io.tmpfile()$0",
      "type": "function",
      "rightLabelHTML": "<b>io</b>.<b>tmpfile</b>()",
      "description": "In case of success, returns a handle for a temporary file. This file is opened in update mode and it is automatically removed when the program ends.",
      "descriptionMoreURL": "#pdf-io.tmpfile",
      "replacementPrefix": "iotmpfile"
    },
    {
      "snippet": "io.type(${1:object})$0",
      "type": "function",
      "rightLabelHTML": "<b>io</b>.<b>type</b>(object)",
      "description": "Checks whether obj is a valid file handle. Returns the string \"file\" if 'object' is an open file handle, \"closed file\" if obj is a closed file handle, or nil if obj is not a file handle.",
      "descriptionMoreURL": "#pdf-io.type",
      "replacementPrefix": "iotype"
    },
    {
      "snippet": "io.write($1)$0",
      "type": "function",
      "rightLabelHTML": "<b>io</b>.<b>write</b>(···)",
      "description": "Equivalent to 'io.output():write(···)'.",
      "descriptionMoreURL": "#pdf-io.write",
      "replacementPrefix": "iowrite"
    },
    {
      "snippet": "file:close()$0",
      "type": "function",
      "rightLabelHTML": "<b>file</b>:<b>close</b>()",
      "description": "Closes 'file'.",
      "descriptionMoreURL": "#pdf-file:close",
      "replacementPrefix": "fileclose"
    },
    {
      "snippet": "file:flush()$0",
      "type": "function",
      "rightLabelHTML": "<b>file</b>:<b>flush</b>()",
      "description": "Saves any written data to 'file'.",
      "descriptionMoreURL": "#pdf-file:flush",
      "replacementPrefix": "fileflush"
    },
    {
      "snippet": "file:lines()$0",
      "type": "function",
      "rightLabelHTML": "<b>file</b>:<b>lines</b>(···)",
      "description": "Returns an iterator function that, each time it is called, reads the file according to the given formats.",
      "descriptionMoreURL": "#pdf-file:lines",
      "replacementPrefix": "filelines"
    },
    {
      "snippet": "file:read($1)$0",
      "type": "function",
      "rightLabelHTML": "<b>file</b>:<b>read</b>(···)",
      "description": "Reads the 'file', according to the given formats, which specify what to read.",
      "descriptionMoreURL": "#pdf-file:read",
      "replacementPrefix": "fileread"
    },
    {
      "snippet": "file:seek(${1:whence}, ${2:offset})$0",
      "type": "function",
      "rightLabelHTML": "<b>file</b>:<b>seek</b>([whence [, offset]])",
      "description": "Returns the final file position, measured in bytes from the beginning of the file.",
      "descriptionMoreURL": "#pdf-file:seek",
      "replacementPrefix": "fileseek"
    },
    {
      "snippet": "file:setvbuf(${1:mode}, ${2:size})$0",
      "type": "function",
      "rightLabelHTML": "<b>file</b>:<b>setvbuf</b>(mode [, size])",
      "description": "Sets the buffering mode for an output file.",
      "descriptionMoreURL": "#pdf-file:setvbuf",
      "replacementPrefix": "filesetvbuf"
    },
    {
      "snippet": "file:write()$0",
      "type": "function",
      "rightLabelHTML": "<b>file</b>:<b>write</b>(···)",
      "description": "Writes the value of each of its arguments to 'file'. The arguments must be strings or numbers.",
      "descriptionMoreURL": "#pdf-file:write",
      "replacementPrefix": "filewrite"
    }
  ],
  "os": [
    {
      "snippet": "os.clock()$0",
      "type": "function",
      "rightLabelHTML": "<b>os</b>.<b>clock</b>()",
      "description": "Returns an approximation of the amount in seconds of CPU time used by the program.",
      "descriptionMoreURL": "#pdf-os.clock",
      "replacementPrefix": "osclock"
    },
    {
      "snippet": "os.date(${1:format}, ${2:time})$0",
      "type": "function",
      "rightLabelHTML": "<b>os</b>.<b>date</b>([format [, time]])",
      "description": "Returns a string or a table containing date and time, formatted according to the given string 'format'.",
      "descriptionMoreURL": "#pdf-os.date",
      "replacementPrefix": "osdate"
    },
    {
      "snippet": "os.time(${1:table})$0",
      "type": "function",
      "rightLabelHTML": "<b>os</b>.<b>time</b>([table])",
      "description": "Returns the current time when called without arguments, or a time representing the local date and time specified by the given table.",
      "descriptionMoreURL": "#pdf-os.time",
      "replacementPrefix": "ostime"
    },
    {
      "snippet": "os.difftime(${1:t2}, ${2:t1})$0",
      "type": "function",
      "rightLabelHTML": "<b>os</b>.<b>difftime</b>(t2, t1)",
      "description": "Returns the difference, in seconds, from time 't1' to time 't2' (where the times are values returned by 'os.time').",
      "descriptionMoreURL": "#pdf-os.difftime",
      "replacementPrefix": "osdifftime"
    },
    {
      "snippet": "os.execute(${1:command})$0",
      "type": "function",
      "rightLabelHTML": "<b>os</b>.<b>execute</b>([command])",
      "description": "This function is equivalent to the ISO C function 'system'. It passes 'command' to be executed by an operating system shell.",
      "descriptionMoreURL": "#pdf-os.execute",
      "replacementPrefix": "osexecute"
    },
    {
      "snippet": "os.exit(${1:code}, ${2:close})$0",
      "type": "function",
      "rightLabelHTML": "<b>os</b>.<b>exit</b>([code [, close]])",
      "description": "Calls the ISO C function exit to terminate the host program.",
      "descriptionMoreURL": "#pdf-os.exit",
      "replacementPrefix": "osexit"
    },
    {
      "snippet": "os.remove(${1:fileName})$0",
      "type": "function",
      "rightLabelHTML": "<b>os</b>.<b>remove</b>(fileName)",
      "description": "Deletes the file (or empty directory, on POSIX systems) with the given name.",
      "descriptionMoreURL": "#pdf-os.remove",
      "replacementPrefix": "osremove"
    },
    {
      "snippet": "os.rename(${1:oldName}, ${2:newName})$0",
      "type": "function",
      "rightLabelHTML": "<b>os</b>.<b>rename</b>(oldName, newName)",
      "description": "Renames the file or directory named 'oldName' to 'newName'.",
      "descriptionMoreURL": "#pdf-os.rename",
      "replacementPrefix": "osrename"
    },
    {
      "snippet": "os.getenv(${1:varName})$0",
      "type": "function",
      "rightLabelHTML": "<b>os</b>.<b>getenv</b>(varName)",
      "description": "Returns the value of the process environment variable 'varName', or nil if the variable is not defined. ",
      "descriptionMoreURL": "#pdf-os.getenv",
      "replacementPrefix": "osgetenv"
    },
    {
      "snippet": "os.setlocale(${1:locale}, ${2:category})$0",
      "type": "function",
      "rightLabelHTML": "<b>os</b>.<b>setlocale</b>(locale [, category])",
      "description": "Sets the current locale of the program.",
      "descriptionMoreURL": "#pdf-os.setlocale",
      "replacementPrefix": "ossetlocale"
    },
    {
      "snippet": "os.tmpname()$0",
      "type": "function",
      "rightLabelHTML": "<b>os</b>.<b>tmpname</b>()",
      "description": "Returns a string with a file name that can be used for a temporary file.",
      "descriptionMoreURL": "#pdf-os.tmpname",
      "replacementPrefix": "ostmpname"
    }
  ],
  "debug": [
    {
      "snippet": "debug.debug()$0",
      "type": "function",
      "rightLabelHTML": "<b>debug</b>.<b>debug</b>()",
      "description": "Enters an interactive mode with the user, running each string that the user enters.",
      "descriptionMoreURL": "#pdf-debug.debug",
      "replacementPrefix": "debdebug"
    },
    {
      "snippet": "debug.gethook(${1:thread})$0",
      "type": "function",
      "rightLabelHTML": "<b>debug</b>.<b>gethook</b>([thread])",
      "description": "Returns the current hook settings of the thread, as three values: the current hook function, the current hook mask, and the current hook count (as set by the 'debug.sethook' function).",
      "descriptionMoreURL": "#pdf-debug.gethook",
      "replacementPrefix": "debgethook"
    },
    {
      "snippet": "debug.getinfo(${1:thread}, ${2:func}, ${3:what})$0",
      "type": "function",
      "rightLabelHTML": "<b>debug</b>.<b>getinfo</b>([thread,] func [, what])",
      "description": "Returns a table with information about a function.",
      "descriptionMoreURL": "#pdf-debug.getinfo",
      "replacementPrefix": "debgetinfo"
    },
    {
      "snippet": "debug.getlocal(${1:thread}, ${2:func}, ${3:local})$0",
      "type": "function",
      "rightLabelHTML": "<b>debug</b>.<b>getlocal</b>([thread,] func, local)",
      "description": "This function returns the name and the value of the local variable with index 'local' of the function at level 'func' of the stack.",
      "descriptionMoreURL": "#pdf-debug.getlocal",
      "replacementPrefix": "debgetlocal"
    },
    {
      "snippet": "debug.getmetatable(${1:value})$0",
      "type": "function",
      "rightLabelHTML": "<b>debug</b>.<b>getmetatable</b>(value)",
      "description": "Returns the metatable of the given 'value' or nil if it does not have a metatable.",
      "descriptionMoreURL": "#pdf-debug.getmetatable",
      "replacementPrefix": "debgetmetatable"
    },
    {
      "snippet": "debug.getregistry()$0",
      "type": "function",
      "rightLabelHTML": "<b>debug</b>.<b>getregistry</b>()",
      "description": "Returns the registry table.",
      "descriptionMoreURL": "#pdf-debug.getregistry",
      "replacementPrefix": "debgetregistry"
    },
    {
      "snippet": "debug.getupvalue(${1:func}, ${2:up})$0",
      "type": "function",
      "rightLabelHTML": "<b>debug</b>.<b>getupvalue</b>(func, up)",
      "description": "This function returns the name and the value of the upvalue with index 'up' of the function 'func'.",
      "descriptionMoreURL": "#pdf-debug.getupvalue",
      "replacementPrefix": "debgetupvalue"
    },
    {
      "snippet": "debug.getuservalue(${1:u})$0",
      "type": "function",
      "rightLabelHTML": "<b>debug</b>.<b>getuservalue</b>(u)",
      "description": "Returns the Lua value associated to 'u'. If 'u' is not a full userdata, returns nil.",
      "descriptionMoreURL": "#pdf-debug.getuservalue",
      "replacementPrefix": "debgetuservalue"
    },
    {
      "snippet": "debug.sethook(${1:thread}, ${2:hook}, ${3:mask}, ${4:count})$0",
      "type": "function",
      "rightLabelHTML": "<b>debug</b>.<b>sethook</b>([thread,] hook, mask [, count])",
      "description": "Sets the given function as a 'hook'. The string 'mask' and the number 'count' describe when the hook will be called.",
      "descriptionMoreURL": "#pdf-debug.sethook",
      "replacementPrefix": "debsethook"
    },
    {
      "snippet": "debug.setlocal(${1:thread}, ${2:level}, ${3:local}, ${4:value})$0",
      "type": "function",
      "rightLabelHTML": "<b>debug</b>.<b>setlocal</b>([thread,] level, local, value)",
      "description": "This function assigns the 'value' to the local variable with index 'local' of the function at 'level' of the stack.",
      "descriptionMoreURL": "#pdf-debug.setlocal",
      "replacementPrefix": "debsetlocal"
    },
    {
      "snippet": "debug.setmetatable(${1:value}, ${2:table})$0",
      "type": "function",
      "rightLabelHTML": "<b>debug</b>.<b>setmetatable</b>(value, table)",
      "description": "Sets the metatable for the given value to the given 'table' (which can be nil). Returns 'value'. ",
      "descriptionMoreURL": "#pdf-debug.setmetatable",
      "replacementPrefix": "debsetmetatable"
    },
    {
      "snippet": "debug.setupvalue(${1:func}, ${2:up}, ${3:value})$0",
      "type": "function",
      "rightLabelHTML": "<b>debug</b>.<b>setupvalue</b>(func, up, value)",
      "description": "This function assigns the 'value' to the upvalue with index 'up' of the function 'func'.",
      "descriptionMoreURL": "#pdf-debug.setupvalue",
      "replacementPrefix": "debsetupvalue"
    },
    {
      "snippet": "debug.setuservalue(${1:udata}, ${2:value})$0",
      "type": "function",
      "rightLabelHTML": "<b>debug</b>.<b>setuservalue</b>(udata, value)",
      "description": "Sets the given value as the Lua 'value' associated to the given 'udata'. Returns 'udata'.",
      "descriptionMoreURL": "#pdf-debug.setuservalue",
      "replacementPrefix": "debsetuservalue"
    },
    {
      "snippet": "debug.traceback(${1:thread}, ${2:message}, ${3:level})$0",
      "type": "function",
      "rightLabelHTML": "<b>debug</b>.<b>traceback</b>([thread,] [message [, level]])",
      "description": "If 'message' is present but is neither a string nor nil, this function returns 'message' without further processing.",
      "descriptionMoreURL": "#pdf-debug.traceback",
      "replacementPrefix": "debtraceback"
    },
    {
      "snippet": "debug.upvalueid(${1:func}, ${2:n})$0",
      "type": "function",
      "rightLabelHTML": "<b>debug</b>.<b>upvalueid</b>(func, n)",
      "description": "Returns a unique identifier (as a light userdata) for the upvalue numbered 'n' from the given function.",
      "descriptionMoreURL": "#pdf-debug.upvalueid",
      "replacementPrefix": "debupvalueid"
    },
    {
      "snippet": "debug.upvaluejoin(${1:f1}, ${2:n1}, ${3:f2}, ${4:n2})$0",
      "type": "function",
      "rightLabelHTML": "<b>debug</b>.<b>upvaluejoin</b>(f1, n1, f2, n2)",
      "description": "Make the 'n1'-th upvalue of the Lua closure 'f1' refer to the 'n2'-th upvalue of the Lua closure 'f2'.",
      "descriptionMoreURL": "#pdf-debug.upvaluejoin",
      "replacementPrefix": "debupvaluejoin"
    }
  ]
}
